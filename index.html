<!--
Real-time Arbitrage Dashboard (single-file HTML)
Supports three arbitrage views:
 1) Spot vs Spot (compare price between two spot markets)
 2) Spot vs Futures (spot price vs futures price)
 3) Futures vs Futures (compare futures price between two futures markets)

Notes:
- For simplicity this demo uses public REST + WebSocket streams where available (Binance spot + Binance futures).
- CORS: some exchange endpoints block direct browser access. Run this file via a local static server (e.g., `npx http-server` or `python -m http.server`) to avoid some CORS issues. If you see CORS errors, run through a small proxy or use the backend server provided earlier.
- This is a frontend-only dashboard (no API keys). It shows live prices, spreads, and alerts.

How to use:
- Open the file in a browser served over HTTP (localhost recommended).
- Choose symbol (default BTC/USDT) and mode (spot-spot / spot-future / future-future).
- For spot-spot choose two spot exchanges (default: Binance, Bitget). For futures choose available futures exchanges.

This file is intended as a readable, extensible starting point.
-->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Real-Time Arbitrage Dashboard — Spot & Futures</title>
  <style>
    :root{--bg:#0b1220;--card:#0f1724;--muted:#94a3b8;--accent:#06b6d4;--good:#10b981;--bad:#ef4444}
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial}
    body{background:linear-gradient(180deg,#071024 0%, #071018 100%);color:#e6eef6;padding:20px;box-sizing:border-box}
    .wrap{max-width:1100px;margin:0 auto}
    header{display:flex;align-items:center;justify-content:space-between;margin-bottom:18px}
    h1{font-size:20px;margin:0}
    .controls{display:flex;gap:10px;flex-wrap:wrap}
    select,input{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:inherit}
    button{padding:8px 12px;border-radius:8px;border:none;background:var(--accent);color:#022;cursor:pointer}
    .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
    .card{background:var(--card);padding:14px;border-radius:12px;box-shadow:0 8px 30px rgba(2,6,23,0.6)}
    .small{font-size:12px;color:var(--muted)}
    .price{font-size:18px;font-weight:700}
    .spread{font-size:16px;margin-top:8px}
    .spread .val{font-weight:800}
    .log{height:220px;overflow:auto;background:#041023;padding:10px;border-radius:8px;color:#9fb0c9}
    footer{margin-top:16px;color:var(--muted);font-size:13px;text-align:center}
    .positive{color:var(--good)}
    .negative{color:var(--bad)}
    @media (max-width:980px){.grid{grid-template-columns:1fr;}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Real-Time Arbitrage Dashboard — Spot & Futures</h1>
      <div class="controls">
        <label class="small">Symbol
          <select id="symbolSelect">
            <option>BTC/USDT</option>
            <option>ETH/USDT</option>
            <option>BNB/USDT</option>
          </select>
        </label>

        <label class="small">Mode
          <select id="modeSelect">
            <option value="spot-spot">Spot ↔ Spot</option>
            <option value="spot-fut">Spot ↔ Futures</option>
            <option value="fut-fut">Futures ↔ Futures</option>
          </select>
        </label>

        <label class="small">Poll (ms)
          <input id="pollMs" type="number" value="2000" style="width:110px" />
        </label>

        <button id="startBtn">Start</button>
        <button id="stopBtn" disabled>Stop</button>
      </div>
    </header>

    <main class="grid">
      <!-- Panel A -->
      <section class="card">
        <div class="small">Market A</div>
        <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
          <select id="marketA" style="flex:1">
            <option value="binance_spot">Binance (Spot)</option>
            <option value="bitget_spot">Bitget (Spot)</option>
            <option value="coinbase_spot">Coinbase (Spot)</option>
            <option value="binance_fut">Binance (Futures)</option>
            <option value="bitget_fut">Bitget (Futures)</option>
          </select>
        </div>
        <div style="margin-top:12px">
          <div class="price"> <span id="priceA">—</span> <span class="small">(<span id="tsA">—</span>)</span></div>
          <div class="small" id="metaA">status: idle</div>
        </div>
      </section>

      <!-- Panel B -->
      <section class="card">
        <div class="small">Market B</div>
        <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
          <select id="marketB" style="flex:1">
            <option value="bitget_spot">Bitget (Spot)</option>
            <option value="binance_spot">Binance (Spot)</option>
            <option value="coinbase_spot">Coinbase (Spot)</option>
            <option value="binance_fut">Binance (Futures)</option>
            <option value="bitget_fut">Bitget (Futures)</option>
          </select>
        </div>
        <div style="margin-top:12px">
          <div class="price"> <span id="priceB">—</span> <span class="small">(<span id="tsB">—</span>)</span></div>
          <div class="small" id="metaB">status: idle</div>
        </div>
      </section>

      <!-- Spread Panel -->
      <section class="card">
        <div class="small">Spread</div>
        <div class="spread">
          <div>Absolute: <span class="val" id="spreadAbs">—</span> USD</div>
          <div>Percent: <span class="val" id="spreadPct">—</span> %</div>
          <div style="margin-top:8px">Action: <span id="action">—</span></div>
        </div>
        <div style="margin-top:12px">
          <label class="small">Alert Threshold (USD)
            <input id="alertThreshold" type="number" value="20" style="width:120px" />
          </label>
        </div>
      </section>

      <!-- Large log card spanning full width (use grid-auto-flow) -->
      <section class="card" style="grid-column:1/-1">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="small">Event Log</div>
          <div class="small">Last update: <span id="lastUpdate">—</span></div>
        </div>
        <div class="log" id="logArea">No data yet.</div>
      </section>
    </main>

    <footer>
      Demo dashboard • Run on localhost for best results • This UI fetches public prices only (no API keys)
    </footer>
  </div>

  <script>
  // -----------------------------
  // Simple exchange price adapters
  // -----------------------------
  // Each adapter exposes: fetchTicker(symbol) -> {price, ts}
  // and optionally supports websockets

  const adapters = {
    // Binance spot REST
    binance_spot: {
      async fetchTicker(sym) {
        // symbol like BTC/USDT -> BTCUSDT
        const pair = sym.replace('/', '');
        const url = `https://api.binance.com/api/v3/ticker/price?symbol=${pair}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error('Binance spot fetch failed');
        const j = await res.json();
        return { price: parseFloat(j.price), ts: Date.now() };
      }
    },

    // Binance futures REST (USDT perpetual on fapi)
    binance_fut: {
      async fetchTicker(sym) {
        const pair = sym.replace('/', '');
        const url = `https://fapi.binance.com/fapi/v1/ticker/price?symbol=${pair}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error('Binance futures fetch failed');
        const j = await res.json();
        return { price: parseFloat(j.price), ts: Date.now() };
      }
    },

    // Bitget (public spot) - REST
    bitget_spot: {
      async fetchTicker(sym) {
        // Bitget uses symbol like BTCUSDT
        const pair = sym.replace('/', '');
        const url = `https://api.bitget.com/api/spot/v1/market/ticker?symbol=${pair}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error('Bitget spot fetch failed');
        const j = await res.json();
        // Bitget response shape: { code: '00000', data: { ... } } or array - try to handle common shapes
        const data = j.data || j;
        // data may be object with last
        const price = parseFloat(data.last || data.lastPrice || (Array.isArray(data) && data[0]?.last) || 0);
        return { price, ts: Date.now() };
      }
    },

    // Bitget futures public
    bitget_fut: {
      async fetchTicker(sym) {
        const pair = sym.replace('/', '');
        const url = `https://api.bitget.com/api/mix/v1/market/ticker?symbol=${pair}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error('Bitget futures fetch failed');
        const j = await res.json();
        const data = j.data || j;
        const price = parseFloat(data.last || data.close || 0);
        return { price, ts: Date.now() };
      }
    },

    // Coinbase Pro spot (REST)
    coinbase_spot: {
      async fetchTicker(sym) {
        const pair = sym.replace('/', '-'); // Coinbase uses BTC-USD normally, but we'll try USDT mapping
        // Coinbase doesn't have USDT pairs in same way; using public ticker for BTC-USD as approximation
        const cb = sym.startsWith('BTC') ? 'BTC-USD' : sym.replace('/', '-')
        const url = `https://api.pro.coinbase.com/products/${cb}/ticker`;
        const res = await fetch(url);
        if (!res.ok) throw new Error('Coinbase fetch failed');
        const j = await res.json();
        return { price: parseFloat(j.price), ts: Date.now() };
      }
    }
  };

  // -----------------------------
  // Dashboard logic
  // -----------------------------
  const el = id => document.getElementById(id);
  let running = false;
  let loopHandle = null;

  function log(msg) {
    const area = el('logArea');
    const t = new Date().toLocaleTimeString();
    area.textContent = `${t} ${msg}\n` + area.textContent;
    el('lastUpdate').textContent = t;
  }

  async function fetchPairPrices(marketKeyA, marketKeyB, symbol) {
    const a = adapters[marketKeyA];
    const b = adapters[marketKeyB];
    // fetch in parallel
    const [ra, rb] = await Promise.allSettled([a.fetchTicker(symbol), b.fetchTicker(symbol)]);
    const outA = ra.status === 'fulfilled' ? ra.value : { price: null, err: ra.reason };
    const outB = rb.status === 'fulfilled' ? rb.value : { price: null, err: rb.reason };
    return { A: outA, B: outB };
  }

  async function tick() {
    const symbol = el('symbolSelect').value;
    const mode = el('modeSelect').value;
    // determine markets based on mode
    let marketAKey = el('marketA').value;
    let marketBKey = el('marketB').value;

    // For spot-fut modes, ensure the select lists make sense; user can choose any though
    try {
      const res = await fetchPairPrices(marketAKey, marketBKey, symbol);
      // update UI for A
      if (res.A.price !== null) {
        el('priceA').textContent = res.A.price.toFixed(2);
        el('tsA').textContent = new Date(res.A.ts).toLocaleTimeString();
        el('metaA').textContent = marketAKey + ' OK';
      } else {
        el('priceA').textContent = '—';
        el('metaA').textContent = 'err: ' + (res.A.err && res.A.err.message);
      }

      // update UI for B
      if (res.B.price !== null) {
        el('priceB').textContent = res.B.price.toFixed(2);
        el('tsB').textContent = new Date(res.B.ts).toLocaleTimeString();
        el('metaB').textContent = marketBKey + ' OK';
      } else {
        el('priceB').textContent = '—';
        el('metaB').textContent = 'err: ' + (res.B.err && res.B.err.message);
      }

      // compute spread
      const pA = res.A.price;
      const pB = res.B.price;
      if (pA != null && pB != null) {
        const abs = Math.abs(pA - pB);
        const pct = (abs / ((pA + pB) / 2)) * 100;
        el('spreadAbs').textContent = abs.toFixed(2);
        el('spreadPct').textContent = pct.toFixed(4);

        const alertThreshold = parseFloat(el('alertThreshold').value || '20');
        if (abs >= alertThreshold) {
          el('action').textContent = 'OPPORTUNITY';
          el('action').className = 'positive';
          log(`ARBITRAGE ALERT: abs=${abs.toFixed(2)} pct=${pct.toFixed(4)} between ${marketAKey} & ${marketBKey}`);
        } else {
          el('action').textContent = 'No opportunity';
          el('action').className = '';
        }
      } else {
        el('spreadAbs').textContent = '—';
        el('spreadPct').textContent = '—';
        el('action').textContent = 'Waiting for prices...';
        el('action').className = '';
      }
    } catch (e) {
      log('Tick error: ' + (e.message || e));
    }
  }

  function startLoop() {
    if (running) return;
    running = true;
    el('startBtn').disabled = true;
    el('stopBtn').disabled = false;
    const ms = parseInt(el('pollMs').value || '2000');
    tick();
    loopHandle = setInterval(tick, ms);
    log('Started dashboard loop (poll ' + ms + 'ms)');
  }

  function stopLoop() {
    if (!running) return;
    running = false;
    el('startBtn').disabled = false;
    el('stopBtn').disabled = true;
    clearInterval(loopHandle);
    log('Stopped dashboard loop');
  }

  el('startBtn').addEventListener('click', startLoop);
  el('stopBtn').addEventListener('click', stopLoop);

  // initialize markets lists depending on mode (bonus: adapt selects for simple UX)
  el('modeSelect').addEventListener('change', (e) => {
    const v = e.target.value;
    // update labels or defaults in simple way
    if (v === 'spot-spot') {
      // ensure selects prefer spot options
      el('marketA').value = 'binance_spot';
      el('marketB').value = 'bitget_spot';
    } else if (v === 'spot-fut') {
      el('marketA').value = 'binance_spot';
      el('marketB').value = 'binance_fut';
    } else if (v === 'fut-fut') {
      el('marketA').value = 'binance_fut';
      el('marketB').value = 'bitget_fut';
    }
  });

  // auto-start minimal polling to show initial
  // Note: do not auto-start websockets — keep polling for simplicity
  // The user must press Start to begin

  </script>
</body>
</html>
